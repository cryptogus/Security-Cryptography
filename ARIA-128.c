/************************************************************************************
*																					*
*					     2021년 09월 27일 ARIA (128 bits key)						*				
* 																					*
*						     정보보안암호수학과 이현호								*				
*																					*
*																					*
**************************************************************************************/
#include <stdio.h>


const unsigned int SBox1[256] = {
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
};

const unsigned int invSBox1[256] = {
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
};

const unsigned int SBox2[256] = {
	0xe2, 0x4e, 0x54, 0xfc, 0x94, 0xc2, 0x4a, 0xcc, 0x62, 0x0d, 0x6a, 0x46, 0x3c, 0x4d, 0x8b, 0xd1,
	0x5e, 0xfa, 0x64, 0xcb, 0xb4, 0x97, 0xbe, 0x2b, 0xbc, 0x77, 0x2e, 0x03, 0xd3, 0x19, 0x59, 0xc1,
	0x1d, 0x06, 0x41, 0x6b, 0x55, 0xf0, 0x99, 0x69, 0xea, 0x9c, 0x18, 0xae, 0x63, 0xdf, 0xe7, 0xbb,
	0x00, 0x73, 0x66, 0xfb, 0x96, 0x4c, 0x85, 0xe4, 0x3a, 0x09, 0x45, 0xaa, 0x0f, 0xee, 0x10, 0xeb,
	0x2d, 0x7f, 0xf4, 0x29, 0xac, 0xcf, 0xad, 0x91, 0x8d, 0x78, 0xc8, 0x95, 0xf9, 0x2f, 0xce, 0xcd,
	0x08, 0x7a, 0x88, 0x38, 0x5c, 0x83, 0x2a, 0x28, 0x47, 0xdb, 0xb8, 0xc7, 0x93, 0xa4, 0x12, 0x53,
	0xff, 0x87, 0x0e, 0x31, 0x36, 0x21, 0x58, 0x48, 0x01, 0x8e, 0x37, 0x74, 0x32, 0xca, 0xe9, 0xb1,
	0xb7, 0xab, 0x0c, 0xd7, 0xc4, 0x56, 0x42, 0x26, 0x07, 0x98, 0x60, 0xd9, 0xb6, 0xb9, 0x11, 0x40,
	0xec, 0x20, 0x8c, 0xbd, 0xa0, 0xc9, 0x84, 0x04, 0x49, 0x23, 0xf1, 0x4f, 0x50, 0x1f, 0x13, 0xdc,
	0xd8, 0xc0, 0x9e, 0x57, 0xe3, 0xc3, 0x7b, 0x65, 0x3b, 0x02, 0x8f, 0x3e, 0xe8, 0x25, 0x92, 0xe5,
	0x15, 0xdd, 0xfd, 0x17, 0xa9, 0xbf, 0xd4, 0x9a, 0x7e, 0xc5, 0x39, 0x67, 0xfe, 0x76, 0x9d, 0x43,
	0xa7, 0xe1, 0xd0, 0xf5, 0x68, 0xf2, 0x1b, 0x34, 0x70, 0x05, 0xa3, 0x8a, 0xd5, 0x79, 0x86, 0xa8,
	0x30, 0xc6, 0x51, 0x4b, 0x1e, 0xa6, 0x27, 0xf6, 0x35, 0xd2, 0x6e, 0x24, 0x16, 0x82, 0x5f, 0xda,
	0xe6, 0x75, 0xa2, 0xef, 0x2c, 0xb2, 0x1c, 0x9f, 0x5d, 0x6f, 0x80, 0x0a, 0x72, 0x44, 0x9b, 0x6c,
	0x90, 0x0b, 0x5b, 0x33, 0x7d, 0x5a, 0x52, 0xf3, 0x61, 0xa1, 0xf7, 0xb0, 0xd6, 0x3f, 0x7c, 0x6d,
	0xed, 0x14, 0xe0, 0xa5, 0x3d, 0x22, 0xb3, 0xf8, 0x89, 0xde, 0x71, 0x1a, 0xaf, 0xba, 0xb5, 0x81,
};

const unsigned int invSBox2[256] = {
	0x30, 0x68, 0x99, 0x1b, 0x87, 0xb9, 0x21, 0x78, 0x50, 0x39, 0xdb, 0xe1, 0x72, 0x09, 0x62, 0x3c,
	0x3e, 0x7e, 0x5e, 0x8e, 0xf1, 0xa0, 0xcc, 0xa3, 0x2a, 0x1d, 0xfb, 0xb6, 0xd6, 0x20, 0xc4, 0x8d,
	0x81, 0x65, 0xf5, 0x89, 0xcb, 0x9d, 0x77, 0xc6, 0x57, 0x43, 0x56, 0x17, 0xd4, 0x40, 0x1a, 0x4d,
	0xc0, 0x63, 0x6c, 0xe3, 0xb7, 0xc8, 0x64, 0x6a, 0x53, 0xaa, 0x38, 0x98, 0x0c, 0xf4, 0x9b, 0xed,
	0x7f, 0x22, 0x76, 0xaf, 0xdd, 0x3a, 0x0b, 0x58, 0x67, 0x88, 0x06, 0xc3, 0x35, 0x0d, 0x01, 0x8b,
	0x8c, 0xc2, 0xe6, 0x5f, 0x02, 0x24, 0x75, 0x93, 0x66, 0x1e, 0xe5, 0xe2, 0x54, 0xd8, 0x10, 0xce,
	0x7a, 0xe8, 0x08, 0x2c, 0x12, 0x97, 0x32, 0xab, 0xb4, 0x27, 0x0a, 0x23, 0xdf, 0xef, 0xca, 0xd9,
	0xb8, 0xfa, 0xdc, 0x31, 0x6b, 0xd1, 0xad, 0x19, 0x49, 0xbd, 0x51, 0x96, 0xee, 0xe4, 0xa8, 0x41,
	0xda, 0xff, 0xcd, 0x55, 0x86, 0x36, 0xbe, 0x61, 0x52, 0xf8, 0xbb, 0x0e, 0x82, 0x48, 0x69, 0x9a,
	0xe0, 0x47, 0x9e, 0x5c, 0x04, 0x4b, 0x34, 0x15, 0x79, 0x26, 0xa7, 0xde, 0x29, 0xae, 0x92, 0xd7,
	0x84, 0xe9, 0xd2, 0xba, 0x5d, 0xf3, 0xc5, 0xb0, 0xbf, 0xa4, 0x3b, 0x71, 0x44, 0x46, 0x2b, 0xfc,
	0xeb, 0x6f, 0xd5, 0xf6, 0x14, 0xfe, 0x7c, 0x70, 0x5a, 0x7d, 0xfd, 0x2f, 0x18, 0x83, 0x16, 0xa5,
	0x91, 0x1f, 0x05, 0x95, 0x74, 0xa9, 0xc1, 0x5b, 0x4a, 0x85, 0x6d, 0x13, 0x07, 0x4f, 0x4e, 0x45,
	0xb2, 0x0f, 0xc9, 0x1c, 0xa6, 0xbc, 0xec, 0x73, 0x90, 0x7b, 0xcf, 0x59, 0x8f, 0xa1, 0xf9, 0x2d,
	0xf2, 0xb1, 0x00, 0x94, 0x37, 0x9f, 0xd0, 0x2e, 0x9c, 0x6e, 0x28, 0x3f, 0x80, 0xf0, 0x3d, 0xd3,
	0x25, 0x8a, 0xb5, 0xe7, 0x42, 0xb3, 0xc7, 0xea, 0xf7, 0x4c, 0x11, 0x33, 0x03, 0xa2, 0xac, 0x60,
};
const unsigned char A[16][16] = { //확산 계층에 쓰일 행렬 GF(2^8)연산
	{0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0},
	{0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1},
	{0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1},
	{1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0},
	{1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1},
	{0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1},
	{1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0},
	{0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0},
	{1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1},
	{1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0},
	{0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1},
	{0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0},
	{0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0},
	{1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0},
	{1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0},
	{0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1}
};

void F0(unsigned char* in, unsigned char* C, unsigned char* output)// 치환계층1 
{
	unsigned char input[16];

	for (int i = 0; i < 16; i++) {
		input[i] = in[i];
	}
	input[0] ^= C[0];
	input[1] ^= C[1];
	input[2] ^= C[2];
	input[3] ^= C[3];
	input[4] ^= C[4];
	input[5] ^= C[5];
	input[6] ^= C[6];
	input[7] ^= C[7];
	input[8] ^= C[8];
	input[9] ^= C[9];
	input[10] ^= C[10];
	input[11] ^= C[11];
	input[12] ^= C[12];
	input[13] ^= C[13];
	input[14] ^= C[14];
	input[15] ^= C[15];

	input[0] = SBox1[input[0]];
	input[1] = SBox2[input[1]];
	input[2] = invSBox1[input[2]];
	input[3] = invSBox2[input[3]];
	input[4] = SBox1[input[4]];
	input[5] = SBox2[input[5]];
	input[6] = invSBox1[input[6]];
	input[7] = invSBox2[input[7]];
	input[8] = SBox1[input[8]];
	input[9] = SBox2[input[9]];
	input[10] = invSBox1[input[10]];
	input[11] = invSBox2[input[11]];
	input[12] = SBox1[input[12]];
	input[13] = SBox2[input[13]];
	input[14] = invSBox1[input[14]];
	input[15] = invSBox2[input[15]];

	for (int i = 0; i < 16; i++) {
		for (int j = 0; j < 16; j++) {
			output[i] ^= A[i][j] * input[j];
		}
	}
}
void Fe(unsigned char *in, unsigned char *C, unsigned char *output)// 치환계층2 
{	
	unsigned char input[16];
	
	for (int i = 0; i < 16; i++) {
		input[i] = in[i];
	}

	input[0]^=C[0];
	input[1]^=C[1];
	input[2]^=C[2];
	input[3]^=C[3];
	input[4]^=C[4];
	input[5]^=C[5];
	input[6]^=C[6];
	input[7]^=C[7];
	input[8]^=C[8];
	input[9]^=C[9];
	input[10]^=C[10];
	input[11]^=C[11];
	input[12]^=C[12];
	input[13]^=C[13];
	input[14]^=C[14];
	input[15]^=C[15];

	input[0] = invSBox1[input[0]];
	input[1] = invSBox2[input[1]];
	input[2] = SBox1[input[2]];
	input[3] = SBox2[input[3]];
	input[4] = invSBox1[input[4]];
	input[5] = invSBox2[input[5]];
	input[6] = SBox1[input[6]];
	input[7] = SBox2[input[7]];
	input[8] = invSBox1[input[8]];
	input[9] = invSBox2[input[9]];
	input[10] = SBox1[input[10]];
	input[11] = SBox2[input[11]];
	input[12] = invSBox1[input[12]];
	input[13] = invSBox2[input[13]];
	input[14] = SBox1[input[14]];
	input[15] = SBox2[input[15]];

	for (int i = 0; i < 16; i++) {
		for (int j = 0; j < 16; j++) {
			output[i] ^= A[i][j] * input[j];
		}
	}

}
void Ff(unsigned char* in, unsigned char* C1, unsigned char* C2, unsigned char* output) {

	unsigned char input[16];

	for (int i = 0; i < 16; i++) {
		input[i] = in[i];
	}

	input[0] ^= C1[0];
	input[1] ^= C1[1];
	input[2] ^= C1[2];
	input[3] ^= C1[3];
	input[4] ^= C1[4];
	input[5] ^= C1[5];
	input[6] ^= C1[6];
	input[7] ^= C1[7];
	input[8] ^= C1[8];
	input[9] ^= C1[9];
	input[10] ^= C1[10];
	input[11] ^= C1[11];
	input[12] ^= C1[12];
	input[13] ^= C1[13];
	input[14] ^= C1[14];
	input[15] ^= C1[15];

	input[0] = invSBox1[input[0]];
	input[1] = invSBox2[input[1]];
	input[2] = SBox1[input[2]];
	input[3] = SBox2[input[3]];
	input[4] = invSBox1[input[4]];
	input[5] = invSBox2[input[5]];
	input[6] = SBox1[input[6]];
	input[7] = SBox2[input[7]];
	input[8] = invSBox1[input[8]];
	input[9] = invSBox2[input[9]];
	input[10] = SBox1[input[10]];
	input[11] = SBox2[input[11]];
	input[12] = invSBox1[input[12]];
	input[13] = invSBox2[input[13]];
	input[14] = SBox1[input[14]];
	input[15] = SBox2[input[15]];

	input[0] ^= C2[0];
	input[1] ^= C2[1];
	input[2] ^= C2[2];
	input[3] ^= C2[3];
	input[4] ^= C2[4];
	input[5] ^= C2[5];
	input[6] ^= C2[6];
	input[7] ^= C2[7];
	input[8] ^= C2[8];
	input[9] ^= C2[9];
	input[10] ^= C2[10];
	input[11] ^= C2[11];
	input[12] ^= C2[12];
	input[13] ^= C2[13];
	input[14] ^= C2[14];
	input[15] ^= C2[15];

	for (int i = 0; i < 16; i++) {
		output[i] = input[i];
	}

}
//rotation (로테이션할 배열, 시프트 값, 시프트 방향, 결과 저장할부분)
void rotation(unsigned char* W, unsigned char N, unsigned char m, unsigned char *X) {
	
	unsigned char Y[16] = { 0, };
	if (N == 19 && m == '>') {
		/////////////// 19 rotation/////////////
		
		for (int i = 15; i > 1; i--) {
			X[i] = W[i - 2];
			Y[i] = X[i];
		}
		X[0] = W[14];
		X[1] = W[15];
		Y[0] = X[0];
		Y[1] = X[1];
		for (int i = 15; i >= 0; i--) {
			X[i] >>= 3;
			Y[i] <<= 5;
		}
		for (int i = 0; i < 15; i++) {
			X[i + 1] = X[i + 1] ^ Y[i];
		}
		X[0] ^= Y[15];
		
	}
	else if (N == 31 && m == '>') {
		/////////////// 31 >>> rotation/////////////

		for (int i = 15; i > 2; i--) {
			X[i] = W[i - 3];
			Y[i] = X[i];
		}
		X[0] = W[13];
		X[1] = W[14];
		X[2] = W[15];
		Y[0] = X[0];
		Y[1] = X[1];
		Y[2] = X[2];
		for (int i = 15; i >= 0; i--) {
			X[i] >>= 7;
			Y[i] <<= 1;
		}
		for (int i = 0; i < 15; i++) {
			X[i + 1] = X[i + 1] ^ Y[i];
		}
		X[0] ^= Y[15];
	}
	else if (N == 31 && m == '<') {
		/////////////// 31 <<< rotation/////////////

		for (int i = 0; i < 13; i++) {
			X[i] = W[i + 3];
			Y[i] = X[i];
		}
		X[13] = W[0];
		X[14] = W[1];
		X[15] = W[2];
		Y[13] = X[13];
		Y[14] = X[14];
		Y[15] = X[15];
		for (int i = 15; i >= 0; i--) {
			X[i] <<= 7;
			Y[i] >>= 1;
		}
		for (int i = 0; i < 15; i++) {
			X[i] = X[i] ^ Y[i+1];
		}
		X[15] ^= Y[0];
	}
	else if (N == 61) {
		/////////////// 61 <<< rotation/////////////

		for (int i = 0; i < 9; i++) {
			X[i] = W[i + 7];
			Y[i] = X[i];
		}
		X[9] = W[0];
		X[10] = W[1];
		X[11] = W[2];
		X[12] = W[3];
		X[13] = W[4];
		X[14] = W[5];
		X[15] = W[6];

		Y[9] = X[9];
		Y[10] = X[10];
		Y[11] = X[11];
		Y[12] = X[12];
		Y[13] = X[13];
		Y[14] = X[14];
		Y[15] = X[15];
		for (int i = 15; i >= 0; i--) {
			X[i] <<= 5;
			Y[i] >>= 3;
		}
		for (int i = 0; i < 15; i++) {
			X[i] = X[i] ^ Y[i + 1];
		}
		X[15] ^= Y[0];
	}
}
void keyexpend(unsigned char *key, unsigned char(*ek)[16]) {
	unsigned char C1[16] = { 0x51,0x7c,0xc1,0xb7,0x27,0x22,0x0a,0x94,0xfe,0x13,0xab,0xe8,0xfa,0x9a,0x6e,0xe0 };
	unsigned char C2[16] = { 0x6d,0xb1,0x4a,0xcc,0x9e,0x21,0xc8,0x20,0xff,0x28,0xb1,0xd5,0xef,0x5d,0xe2,0xb0 };
	unsigned char C3[16] = { 0xdb,0x92,0x37,0x1d,0x21,0x26,0xe9,0x70,0x03,0x24,0x97,0x75,0x04,0xe8,0xc9,0x0e };
	unsigned char W0[16], W1[16] = { 0, }, W2[16] = { 0, }, W3[16] = { 0, };
	
	/**********************ARIA-128에서의 W0~3 값 생성**************************/
	for (int i = 0; i < 16; i++) {
		W0[i] = key[i];
	}

	F0(W0,C1,W1);

	Fe(W1, C2, W2);

	for (int i = 0; i < 16; i++) {
		W2[i] ^= W0[i];
	}

	F0(W2, C3, W3);
	for (int i = 0; i < 16; i++) {
		W3[i] ^= W1[i];
	}

	/***************************W0~3 값 확인********************/
	//for (int i = 0; i < 16; i++) {
	//
	//	printf("%02x ", W0[i]);
	//}
	//printf("\n");
	//for (int i = 0; i < 16; i++) {
	//	
	//	printf("%02x ", W1[i]);
	//}
	//printf("\n");
	//for (int i = 0; i < 16; i++) {
	//
	//	printf("%02x ", W2[i]);
	//}
	//printf("\n");
	//for (int i = 0; i < 16; i++) {
	//
	//	printf("%02x ", W3[i]);
	//}
	
	unsigned char X[16] = { 0, };
	rotation(W1, 19, '>', X);
	for (int i = 0; i < 16; i++) {
		ek[0][i] = W0[i] ^ X[i];
	}
	rotation(W2, 19, '>', X);
	for (int i = 0; i < 16; i++) {
		ek[1][i] = W1[i] ^ X[i];
	}
	rotation(W3, 19, '>', X);
	for (int i = 0; i < 16; i++) {
		ek[2][i] = W2[i] ^ X[i];
	}
	rotation(W0, 19, '>', X);
	for (int i = 0; i < 16; i++) {
		ek[3][i] = W3[i] ^ X[i];
	}
	rotation(W1, 31, '>', X);
	for (int i = 0; i < 16; i++) {
		ek[4][i] = W0[i] ^ X[i];
	}
	rotation(W2, 31, '>', X);
	for (int i = 0; i < 16; i++) {
		ek[5][i] = W1[i] ^ X[i];
	}
	rotation(W3, 31, '>', X);
	for (int i = 0; i < 16; i++) {
		ek[6][i] = W2[i] ^ X[i];
	}
	rotation(W0, 31, '>', X);
	for (int i = 0; i < 16; i++) {
		ek[7][i] = W3[i] ^ X[i];
	}
	rotation(W1, 61, '<', X);
	for (int i = 0; i < 16; i++) {
		ek[8][i] = W0[i] ^ X[i];
	}
	rotation(W2, 61, '<', X);
	for (int i = 0; i < 16; i++) {
		ek[9][i] = W1[i] ^ X[i];
	}
	rotation(W3, 61, '<', X);
	for (int i = 0; i < 16; i++) {
		ek[10][i] = W2[i] ^ X[i];
	}
	rotation(W0, 61, '<', X);
	for (int i = 0; i < 16; i++) {
		ek[11][i] = W3[i] ^ X[i];
	}
	rotation(W1, 31, '<', X);
	for (int i = 0; i < 16; i++) {
		ek[12][i] = W0[i] ^ X[i];
	}
}

void ARIA_en(unsigned char plaintext[], unsigned char key[], unsigned char ciphertext[]) {
	unsigned char ek[13][16];
	keyexpend(key, ek);
	/**************키확장 잘됨******************/
	//for (int i = 0; i < 13; i++) {
	//	for (int j = 0; j < 16; j++) {
	//		printf("%02x ", ek[i][j]);
	//	}
	//	printf("\n\n");
	//}
	unsigned char state[13][16] = { 0, };
	F0(plaintext, ek[0], state[0]);
	Fe(state[0], ek[1], state[1]);
	F0(state[1], ek[2], state[2]);
	Fe(state[2], ek[3], state[3]);
	F0(state[3], ek[4], state[4]);
	Fe(state[4], ek[5], state[5]);
	F0(state[5], ek[6], state[6]);
	Fe(state[6], ek[7], state[7]);
	F0(state[7], ek[8], state[8]);
	Fe(state[8], ek[9], state[9]);
	F0(state[9], ek[10], state[10]);
	
	//for (int i = 1; i < 10;) {
	//	Fe(ciphertext, ek[i], ciphertext);
	//	F0(ciphertext, ek[i + 1], ciphertext);
	//}
	Ff(state[10], ek[11], ek[12], ciphertext);
}
int main() {
	//test vector//
	unsigned char plaintext[16] = { 0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff };
	unsigned char key[16] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };
	unsigned char ciphertext[16] = { 0, };
	ARIA_en(plaintext, key, ciphertext);
	for (int i = 0; i < 16; i++)
		printf("%02x ", ciphertext[i]);

}